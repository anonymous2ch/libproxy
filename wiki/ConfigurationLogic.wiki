#summary Configuration logic as found on other implementation.
#labels Phase-Design

= Introduction =

As the proxy configuration predates libproxy, we need to consider previous implementation behavior to ensure consistency with user expectations. This wiki pages presents analyses of well known implementation base on the platform  they run on.

= Linux =

On Linux the pioneer of proxy support is Mozilla browsers (former Netscape). But other browsers do support proxy and has it's own proxy configuration interpretation logic. Current Gnome proxy settings is a copy of Firefox settings.

== Firefox and Chromium ==

After some testing we found that Chromium (the Google Webkit based browser) mimic perfectly Firefox behavior. In manual proxy configuration mode, those browsers chooses a proxy base on the most generic solution (SOCKS) to the most specific (per protocol proxies), with an exception when a single proxy is set for all protocols. Only one protocol is selected and no fallback will occur in the case of failures. Those browsers support SOCKS, HTTP, HTTPS, FTP and Gopher. They also support use and discovery of PAC files, where logic is within the script. Next is the logic represent as pseudo code:

    * IF not using same proxy for all protocols THEN
        * IF SOCKS is set THEN use it
        * ELSE IF protocol specific proxy is set THEN use it
        * ELSE IF using same proxy for all protocols THEN
            * IF SOCKS is set THEN use it
    * IF no proxy has been set THEN use direct connection

== Konqueror ==

This is the default browser in the KDE desktop environment. This browser have not been tested yet.

= OS X =

OS X uses it's own way for proxy settings. It supports protocols including SOCKS, HTTP, HTTPS, FTP, Gopher, RTSP, and automatic configuration through PAC files. For sake of simplicity, we have tested the logic with the default browser Safari.

== Safari ==

Safari interpret proxy logic differently from Firefox. If multiple proxy are configured, it try each of them until a connection is established. From our testing the order seems to be from most specific to most generic (starting with manual configuration). Next is the logic represented as pseudo code:

    * DEFINE proxy_list as list
    * IF protocol specific proxy is set THEN add it to proxy_list
    * IF SOCKS proxy is set THEN append it to proxy_list
    * IF PAC auto-configuration is set THEN append it to proxy_list
    * FOREACH proxy in proxy_list
        * connect to proxy
        * IF connection failed THEN continue
        * ELSE stop

= Windows =

This platform has not been tested yet.